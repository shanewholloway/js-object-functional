import @{}
  o_assign, o_create, o_freeze, o_defineProperties, o_getPrototypeOf
from './impl_object_fns.jsy'

import bindNotifyFunction from './impl_notify.jsy'
import stateActionDispatch from './impl_dispatch.jsy'

export * from './impl_notify.jsy'
export * from './impl_dispatch.jsy'

export function ObjectFunctional() ::
  return asFunctionalInstance(this)

export function asFunctionalInstance(host_inst, ...options) ::
  return asFunctionalHost @ host_inst, o_getPrototypeOf(host_inst),
    o_assign({}, ...options)


export default asFunctionalObject
export function asFunctionalObject(host_obj, ...options) ::
  return asFunctionalHost @ o_create(host_obj), host_obj,
    o_assign({}, ...options)


// ---

export function asFunctionalHost(host, proto_host, options) ::
  // initialize options
  const notify = null == options.notify
    ? bindNotifyFunction()
    : options.notify


  // setup asAction setter hack -- in lieu of ES standard decorators
  const _act = bindActionDeclarations(notify)
  const dispatchAction = _act.dispatchAction
  const defineAction = _act.defineAction
  if options.actions :: defineAction(options.actions)

  const subscribe = @{} value(...args) :: return notify.subscribe(...args)
  const __impl_proto__ = o_create @ proto_host, @{} subscribe
  const __view_proto__ = o_create @ proto_host, @{} subscribe

  o_defineProperties @ host, @{}
    subscribe, asAction: @{} set: defineAction
    __impl_proto__: @{} configurable: true, value: __impl_proto__
    __view_proto__: @{} configurable: true, value: __view_proto__


  // initialize the internal stat with initial view
  dispatchAction(notify, null, [], null)

  return o_freeze @ o_create @ host


  function bindActionDeclarations(notify) ::
    let dispatchAction
    if null != options.dispatchAction ::
      dispatchAction = options.dispatchAction
      if 'function' !== typeof dispatchAction ::
        throw new TypeError(`Expected a dispatchAction(notify, actionName, actionArgs){â€¦} function`)
    else if 'function' === typeof host.__dispatch__ ::
      dispatchAction = function(notify, actionName, actionArgs) ::
        return host.__dispatch__(notify, actionName, actionArgs)
    else ::
      dispatchAction = stateActionDispatch(host, options)


    const defineAction = (actionList) => ::
      if undefined === actionList || null === actionList :: return
      else if 'function' === typeof actionList ::
        actionList = @[] @[] actionList.name, actionList
      else if 'string' === typeof actionList ::
        actionList = @[] @[] actionList, host[actionList]
      else if ! Array.isArray @ actionList ::
        actionList = Object.entries(actionList)
      else if 'string' === typeof actionList[0] ::
        actionList = @[] actionList


      const impl_props={}, view_props={}, host_props = {}
      for const [actionName, fnAction] of actionList ::
        if ! actionName ::
          throw new TypeError @ `Action name not found`
        if 'function' !== typeof fnAction ::
          throw new TypeError @ `Expected action "${actionName}" to be a function, but found "${typeof fnAction}"`

        const fnDispatch = function (...actionArgs) ::
          return dispatchAction(notify, actionName, actionArgs)

        impl_props[actionName] = @{} value: fnAction
        view_props[actionName] = @{} value: fnDispatch
        host_props[actionName] = @{} value: fnDispatch, configurable: true

      o_defineProperties @ __impl_proto__, impl_props
      o_defineProperties @ __view_proto__, view_props
      o_defineProperties @ host, host_props

    return @{} dispatchAction, defineAction

